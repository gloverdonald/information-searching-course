Lavritech:
теперь
с
дисплеем
и
платой
управления
(наконец-то
дождались)
/
Хабр
β
Рейтинг
минут
назад
Lavritech:
теперь
с
дисплеем
и
платой
управления
(наконец-то
дождались)
Средний
мин
Туториал
В
своё
время
в
беседе
с
разработчиками
Lavritech
я
высказал
пожелание
оснастить
их
контроллеры
дисплеем
платой
управления
и
индикации
—
у
меня
не
вызывает
сомнений
что
это
простое
дополнение
значительно
расширяет
возможности
и
удобство
пользования
контроллером
Но
как
говорится
быстро
сказка
сказывается
да
не
быстро
дело
делается
—
прошло
около
полутора
лет
—
и
вот
на
моём
столе
новая
версия
контроллера
Lavritech
со
встроенным
разъёмом
для
платы
расширения
и
с
самой
платой
дисплея
и
управления
Вообще
—
красота
и
именно
то
что
я
(все
мы)
так
долго
ждали
Давайте
посмотрим
как
это
устроено
и
как
это
работает
на
практике
❯
Новая
версия
контроллера
В
моём
распоряжении
оказался
контроллер
с
материнской
платой
последней
на
данный
момент
версии
кроме
всего
прочего
оснащённой
специальным
разъёмом
для
подключения
платы
управления
и
самой
же
дисплейной
платой
Поскольку
аппаратная
основа
контроллеров
Lavritech
полностью
модульная
то
в
контексте
какой-то
конкретной
модели
имеет
смысл
говорить
только
о
версии
материнской
платы
—
набор
функциональных
модулей
в
контроллере
может
быть
установлен
любой
всё
зависит
от
пожеланий
покупателя
и
требований
его
проекта
В
моём
случае
в
контроллере
установлены
модуль
интерфейса
RS
и
модуль
для
подключения
-Wire
сети
датчиков
температуры
DS
B
(LTE
-RS
-SM
и
LTE
-DIO
-IO-H
соответственно)
Плюс
Ethernet
модуль
и
модуль
беспроводной
LoRa
связи
Ну
и
центральный
модуль
ESP
естественно
В
общем
получается
достаточно
функциональная
«машинка»
для
выполнения
IoT
проектов
Изюминка
в
данном
случае
заключается
в
том
что
в
любой
момент
можно
изменить
конфигурацию
и
функционал
контроллера
просто
заменив
один
интерфейсный
модуль
на
другой
Кстати
на
фото
можно
также
видеть
что
контроллер
укомплектован
модулем
DC-DC
преобразователя
для
питания
от
напряжения
-
вольт
❯
Плата
управления
Плата
управления
(она
же
«дисплейная
плата»
или
«дисплейный
модуль»)
устанавливается
в
верхнюю
крышку
корпуса
контроллера
и
достаточно
просто
и
надёжно
крепится
в
ней
на
защёлках
С
материнской
платой
дисплейный
модуль
соединяется
я
бы
сказал
элегантным
шлейфиком
Причём
шлейфик
именно
такой
какой
нужен
(редкий
случай)
—
не
длинный
и
не
короткий
и
с
миниатюрным
но
легко
соединяемым
и
разъединяемым
разъёмом
Материнская
плата
ревизии
имеет
соответствующий
разъём
для
подключения
управляющей
платы
Разумеется
если
вам
нужен
дисплейный
модуль
его
можно
установить
в
контроллер
а
если
ваш
проект
не
требует
дисплея
и
управления
с
передней
панели
контроллера
то
его
можно
не
устанавливать
—
сделано
всё
идеально
с
точки
зрения
комплектования
контроллеров
под
различные
проекты
Сам
дисплейный
разъём
является
модификацией
и
расширением
т
н
«EUHP»
разъёма
экосистемы
Lavritech
(подробнее
об
архитектуре
контроллеров
Lavritech
см
в
предыдущих
статьях
цикла)
Он
содержит
контакты
SPI
и
I
C
интерфейсов
выводы
GPIO
и
питания
и
В
Распиновка
этого
разъёма
может
отличаться
в
зависимости
от
наличия
или
отсутствия
на
плате
модулей
Ethernet
(
)
и
LoRa
(
)
Подробнее
об
устройстве
дисплейного
разъёма
см
в
документации
производителя
❯
Схемотехника
модуля
Вообще
по
задумке
разработчиков
Lavritech
управляющая
плата
(управляющие
платы)
может
иметь
различные
модификации
с
различным
функционалом:
на
ней
могут
быть
установлены
различные
типы
дисплеев
управляющие
элементы
(кнопки
джойстик
и
т
п
)
различное
количество
индикаторных
светодиодов
и
т
п
Плюс
наличие
интерфейсов
I
C
и
SPI
позволяет
выносить
на
управляющую
плату
дополнительные
компоненты
например
датчики
и
т
п
Благодаря
такой
архитектуре
возможно
также
создание
заказных
управляющих
панелей
под
конкретные
проекты
или
для
OEM
заказчиков
DIY
энтузиастам
это
позволяет
не
создавать
весь
контроллер
с
нуля
а
разработать
только
кастомную
переднюю
панель
«контроллера
своей
мечты»
взяв
за
основу
своего
решения
материнскую
плату
Lavritech
В
моём
конкретном
случае
передняя
панель
имеет
официальное
название
«LTEU-DISPxxxx»
и
содержит
I
C
дисплей
SH
управляемый
напрямую
по
шине
I
C
четыре
кнопки
и
четыре
светодиода
управляемых
через
расширитель
портов
PCF
AT
(находится
на
плате
под
дисплеем)
По
обратной
стороне
платы
видно
что
она
очень
многофункциональна
и
позволяет
различным
образом
конфигурировать
подключённые
компоненты
Принципиальная
электрическая
схема
дисплейного
модуля
производителем
не
раскрывается
поэтому
сразу
переходим
к
обзору
внешнего
вида
новых
контроллеров
❯
Передняя
панель
В
базовом
варианте
контроллер
поставляется
с
прозрачной
передней
панелью
в
модном
стиле
«Hacker
Design»
то
есть
через
эту
панель
видна
вся
электронная
начинка
контроллера
Решение
спорное
но
что-то
в
этом
определённо
есть
(мне
лично
нравится)
Одновременно
тут
открывается
широкое
поле
для
экспериментов
с
дизайном
—
можно
сделать
непрозрачную
крышку
сделать
внутреннее
матирование
прозрачной
панели
изменить
цвет
и
т
д
Ниже
представлено
фото
подобного
контроллера
но
с
красным
прозрачным
стеклом
и
кастомной
платой
управления
со
встроенными
датчиками
❯
Готовые
прошивки
С
аппаратным
обеспечением
в
первом
приближении
мы
разобрались
теперь
давайте
поговорим
о
том
как
программировать
это
чудо
техники
В
базовом
варианте
контроллеры
Lavritech
рассчитаны
на
работу
с
собственной
фирменной
прошивкой
(платной)
являющейся
адаптацией
и
развитием
популярной
прошивки
WiFi-IoT
То
есть
многочисленные
фанаты
WiFi-IoT
будут
довольны
—
здесь
не
нужно
ничего
программировать
нужно
только
грамотно
расставить
галочки
в
веб-интерфейсе
Но
мне
лично
вариант
с
готовыми
прошивками
совершенно
не
интересен
—
если
вы
умеете
программировать
вообще
и
программировать
ESP
в
частности
то
использование
готовых
решений
типа
«байт
взял
—
байт
передал»
выглядит
как
забивание
гвоздей
микроскопом
Поэтому
не
будем
задерживаться
и
перейдём
к
самому
интересному
—
самостоятельному
программированию
контроллера
Lavritech
с
дисплейным
модулем
❯
Программирование
Самостоятельное
программирование
позволяет
реализовать
любые
свои
хотелки
и
капризы
но
требует
определённой
квалификации
и
трудозатрат
на
написание
кода
(и
ещё
в
большей
степени
—
воображения
и
творческого
подхода
к
делу)
Начнём
мы
с
самого
очевидного
—
программирования
дисплея
и
вывода
на
него
тестовой
информации
Для
этого
воспользуемся
Arduino
библиотекой
для
и
дополнительной
библиотекой
/*

Lavritech
SH
display
test

(
x
I
C
SH
X)
*/

#include
<SPI
h>
#include
<Wire
h>
#include
<Adafruit_GFX
h>
#include
<Adafruit_SH
X
h>

#define
I
C_Address
x
c

#define
SCREEN_WIDTH

#define
SCREEN_HEIGHT

#define
OLED_RESET
-

Adafruit_SH
G
display
=
Adafruit_SH
G(SCREEN_WIDTH
SCREEN_HEIGHT
&Wire
OLED_RESET);


void
setup()
{

Serial
begin(
);

Serial
println(F("Start
SH
test
"));



Wire
begin(
);

delay(
);



display
begin(I
C_Address
true);

display
clearDisplay();


display
setTextColor(SH
X_WHITE);

display
setCursor(
);

display
setTextSize(
);

display
setTextColor(SH
X_WHITE);
display
println("Lavritech");



display
setTextSize(
);

display
println();

display
setTextColor(SH
X_BLACK
SH
X_WHITE);
display
println("SH
");

display
setTextColor(SH
X_WHITE
SH
X_BLACK);
display
println("Display
Test");

display
display();

display
clearDisplay();
}

void
loop()
{

}

Здесь
достаточно
взять
стандартный
код
примера
и
задать
корректные
значения
номеров
GPIO
для
интерфейса
I
C
(SDA
SCL)
на
контроллерах
Lavritech
Wire
begin(
);

Результат
в
точности
соответствует
ожиданиям
—
вывод
на
дисплей
контроллера
в
полной
нашей
власти:
мы
можем
выводить
любую
информацию
и
тогда
когда
нам
нужно
по
условиям
проекта
❯
Управление
светодиодами
На
дисплейной
плате
(кроме
собственно
дисплея)
имеются
четыре
свободно
программируемых
светодиода
подключённых
через
расширитель
портов
PCF
AT
(выводы
P
P
P
и
P
)
Для
управления
светодиодами
воспользуемся
библиотекой
/*

Lavritech
Display
module
LEDS
test
*/

#include
"Arduino
h"
#include
"PCF
h"

#define
I
C_LEDS_ADR
x


PCF
pcf(I
C_LEDS_ADR
);

void
setup()
{

Serial
begin(
);

Serial
println();

Serial
println(F("Start
Display
module
LEDS
test
"));


pcf
pinMode(P
OUTPUT);

pcf
pinMode(P
OUTPUT);

pcf
pinMode(P
OUTPUT);

pcf
pinMode(P
OUTPUT);


Serial
print("Init
PCF
");

if
(pcf
begin()){Serial
println(F("Ok"));}

else
{Serial
println(F("Error"));}
}

void
action_on(byte
n)
{

pcf
digitalWrite(n
LOW);

Serial
print(F("LED
#"));
Serial
print(n);
Serial
println(F("
ON"));
}

void
action_off(byte
n)
{

pcf
digitalWrite(n
HIGH);

Serial
print(F("LED
#"));
Serial
print(n);
Serial
println(F("
OFF"));
}

void
loop()
{

action_on(P
);
action_on(P
);
action_on(P
);
action_on(P
);

delay(
);

action_off(P
);
action_off(P
);
action_off(P
);
action_off(P
);

delay(
);
}

На
фото
обратной
стороны
платы
(см
выше)
есть
таблица
установки
значений
I
C
адреса
для
микросхемы
PCF
AT
(JP
JP
JP
)
Поскольку
ни
одна
перемычка
не
замкнута
то
адрес
микросхемы
в
нашем
случае
—
x
Соответственно
задаём
адрес
расширителя
портов
и
номера
GPIO
I
C
интерфейса
контроллера:
#define
I
C_LEDS_ADR
x


PCF
pcf(I
C_LEDS_ADR
);

И
получаем
результат
превосходящий
все
ожидания:
загораются
совершенно
неземным
светом
четыре
янтарных
светодиода
(красота)
А
вообще
можно
сделать
светодиоды
с
разным
цветом
свечения
для
обозначения
типа
происходящих
событий
—
ошибка
штатная
работа
включение
беспроводной
или
Ethernet
связи
и
т
д
А
также
можно
добавить
ещё
ряд
светодиодов
для
индикации
состояния
входов/выходов
Отлично
осталось
только
разобраться
с
управлением
кнопками
❯
Работа
с
кнопками
Работа
с
кнопками
не
намного
отличается
от
управления
светодиодами
—
используется
всё
та
же
микросхема
PCF
AT
но
только
с
выводами
P
P
P
и
P
Создаём
тестовый
скетч:
/*

Lavritech
Display
module
Keys
test
*/

#include
"Arduino
h"
#include
"PCF
h"

#define
I
C_DIGITAL_ADR
x


PCF
pcf(I
C_DIGITAL_ADR
);

void
setup()
{

Serial
begin(
);

Serial
println();

Serial
println(F("Start
Display
module
Keys
test
"));


pcf
pinMode(P
INPUT);

pcf
pinMode(P
INPUT);

pcf
pinMode(P
INPUT);

pcf
pinMode(P
INPUT);


Serial
print("Init
PCF
");

if
(pcf
begin()){Serial
println(F("Ok"));}

else
{Serial
println(F("Error"));}


delay(
);
}

void
loop()
{

if
(pcf
digitalRead(P
)
==
LOW)
Serial
println("Key
pressed");

if
(pcf
digitalRead(P
)
==
LOW)
Serial
println("Key
pressed");

if
(pcf
digitalRead(P
)
==
LOW)
Serial
println("Key
pressed");

if
(pcf
digitalRead(P
)
==
LOW)
Serial
println("Key
pressed");

delay(
);
}

И
наблюдаем
в
Serial
вывод
данных
о
нажатых
на
передней
панели
кнопках
(почему-то
порядок
номеров
кнопок
инвертирован
—
первой
(верхней)
кнопке
соответствует
последний
вывод
P
❯
Заключение
Вот
собственно
и
всё:
имеем
отличный
модульный
контроллер
с
дисплейной
передней
панелью
кнопками
управления
и
свободно
программируемыми
светодиодами
для
индикации
любых
статусов
вашей
IoT
системы
Причём
можем
самостоятельно
(как
угодно)
программировать
этот
контроллер
или
воспользоваться
готовой
прошивкой
«прямо
из
коробки»
Более
подробную
информацию
о
контроллерах
Lavritech
и
их
архитектуре
можно
почерпнуть
из
предыдущих
статей
цикла:
Теги:
Хабы:
+
Компания
Карма
Рейтинг
Пользователь
Публикации
Лучшие
за
сутки
Похожие
Информация
Сайт
Дата
регистрации
августа
Дата
основания
мая
Численность
–
человек
Местоположение
Россия
Представитель
Ваш
аккаунт
Разделы
Информация
Услуги
Настройка
языка
©
–
