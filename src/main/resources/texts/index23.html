Бэкдоры
в
микрокоде
ассемблерных
инструкций
процессоров
x
/
Хабр
β
окт
в
:
Бэкдоры
в
микрокоде
ассемблерных
инструкций
процессоров
x
мин
K
Софту
мы
не
доверяем
уже
давно
и
поэтому
осуществляем
его
аудит
проводим
обратную
инженерию
прогоняем
в
пошаговом
режиме
запускаем
в
песочнице
Что
же
насчёт
процессора
на
котором
выполняется
наш
софт?
–
Мы
слепо
и
беззаветно
доверяем
этому
маленькому
кусочку
кремния
Однако
современное
железо
имеет
те
же
самые
проблемы
что
и
софт:
секретную
недокументированную
функциональность
ошибки
уязвимости
малварь
трояны
руткиты
бэкдоры
ISA
(Instruction
Set
Architecture)
x
–
одна
из
самых
долгих
непрерывно
изменяющихся
«архитектур
набора
команд»
в
истории
Начиная
с
дизайна
разработанного
в
году
ISA
претерпевает
постоянные
изменения
и
обновления;
сохраняя
при
этом
обратную
совместимость
и
поддержку
исходной
спецификации
За
лет
своего
взросления
архитектура
ISA
обросла
и
продолжает
обрастать
множеством
новых
режимов
и
наборов
инструкций
каждый
из
которых
добавляет
к
предшествующему
дизайну
и
без
того
перегруженному
новый
слой
Из-за
политики
полной
обратной
совместимости
в
современных
процессорах
x
присутствуют
даже
те
инструкции
и
режимы
которые
на
сегодняшний
день
уже
преданы
полному
забвению
В
результате
мы
имеем
архитектуру
процессора
которая
представляет
собой
сложно
переплетающийся
лабиринт
новых
и
антикварных
технологий
Такая
чрезвычайно
сложная
среда
–
порождает
множество
проблем
с
кибербезопасностью
процессора
Поэтому
процессоры
x
не
могут
претендовать
на
роль
доверенного
корня
критической
киберинфраструктуры
Вы
всё
ещё
доверяете
своему
процессору?
Безопасность
программ
и
операционной
системы
–
зиждется
на
безопасности
железа
на
котором
они
развёрнуты
Как
правило
разработчики
софта
не
учитывают
того
факта
что
железо
на
котором
разворачивается
их
софт
–
может
быть
недоверенным
вредоносным
Когда
железо
ведёт
себя
ошибочно
(независимо
оттого
преднамеренно
или
нет)
программные
механизмы
безопасности
–
полностью
обесцениваются
Уже
много
лет
предлагаются
различные
модели
защищённых
процессоров:
Intel
SGX
AMD
Pacifica
и
др
Тем
не
менее
завидная
регулярность
с
которой
публикуется
информация
о
критических
сбоях
(из
недавних
например
Meltdown
и
Spectre)
и
обнаруженных
недокументированных
«отладочных»
функциях
–
наводит
на
мысль
что
наше
беззаветное
доверие
к
процессорам
беспочвенно
Современные
процессоры
x
представляют
собой
очень
громоздкое
и
запутанное
переплетение
новейших
и
антикварных
технологий
У
было
тыс
транзисторов
у
Pentium
–
млн
у
Broadwell
–
млрд
у
Cannonlake
–
больше
млрд
При
таком
количестве
транзисторов
неудивительно
что
современные
процессоры
x
испещрены
недокументированными
инструкциями
и
аппаратными
уязвимостями
Среди
недокументированных
–
обнаруженных
почти
случайно
–
инструкций:
ICEBP
(
xF
)
LOADALL
(
x
F
)
apicall
(
x
FFFF
)
[
]
которые
позволяют
разблокировать
процессор
для
несанкционированного
доступа
к
защищённым
областям
памяти
Что
же
касается
многочисленных
аппаратных
уязвимостей
процессоров
(см
два
рисунка
ниже)
то
они
позволяют
киберзлоумышленнику
осуществлять
эскалацию
привилегий
[
]
извлекать
криптографические
ключи
[
]
создавать
новые
ассемблерные
инструкции
[
]
менять
функциональность
уже
существующих
ассемблерных
инструкций
[
]
устанавливать
хуки
на
ассемблерные
инструкции
[
]
брать
под
контроль
«аппаратно
ускоренную
виртуализацию»
[
]
вмешиваться
в
«атомарные
криптографические
вычисления»
[
]
и
–
сладкое
напоследок
–
входить
в
«режим
бога»:
подчинять
себе
легальный
аппаратный
бэкдор
Intel
ME
(который
позволяет
получать
удалённый
доступ
даже
к
выключенному
компьютеру)
[
]
И
всё
это
–
не
оставляя
каких-либо
цифровых
следов
Современные
процессоры
–
это
больше
софт
чем
железо
Строго
говоря
современные
процессоры
даже
нельзя
назвать
«железом»
в
полном
смысле
этого
слова
Потому
что
наиболее
критичная
их
функциональность
(в
том
числе
ISA)
–
обеспечивается
перепрошиваемым
микрокодом
Изначально
микрокод
отвечал
в
основном
за
то
чтобы
управлять
декодированием
и
выполнением
сложных
ассемблерных
инструкций:
операции
с
плавающей
точкой
MMX-примитивы
обработчики
строк
с
префиксом
REP
и
т
п
Однако
с
течением
времени
на
микрокод
возлагается
всё
больше
и
больше
ответственности
за
обработку
операций
внутри
процессора
Так
например
современные
расширения
процессоров
Intel
такие
как
AVX
(Advanced
Vector
Extensions)
и
VT-d
(аппаратная
виртуализация)
–
реализованы
на
микрокоде
Кроме
того
сегодня
микрокод
отвечает
в
числе
прочего
за
сохранение
состояния
процессора
за
управление
кэшем
и
также
за
управление
энергосбережением
Для
энергосбережения
на
микрокоде
реализован
механизм
прерываний
обрабатывающий
состояния
электропитания:
С-состояния
(степень
энергосберегающего
сна:
от
активного
состояния
до
глубокого
сна)
и
P-состояния
(разные
комбинации
вольтажа
и
частоты)
Так
например
за
обнуление
L
-кэша
при
входе
в
состояние
C
а
также
при
выходе
из
него
–
отвечает
именно
микрокод
Зачем
производители
процессоров
пользуются
микрокодом?
Производители
процессоров
x
используют
микрокод
для
разложения
сложных
ассемблерных
инструкций
(длина
которых
может
достигать
байт)
в
цепочку
простых
микроинструкций
–
в
целях
упрощения
аппаратной
архитектуры
и
облегчения
диагностики
По
сути
микрокод
это
интерпретатор
между
внешней
(видимой
для
пользователя)
CISC-архитектурой
и
внутренней
(аппаратной)
RISC-архитектурой
При
обнаружении
ошибок
в
CISC-архитектуре
(в
ISA
прежде
всего)
производители
публикуют
обновление
микрокода
которое
можно
закачать
в
процессор
через
BIOS/UEFI
материнской
платы
или
через
операционную
систему
(во
время
процесса
загрузки)
Благодаря
такой
системе
обновлений
основанной
на
микрокодах
производители
процессоров
обеспечивают
себе
гибкость
и
снижение
затрат
–
при
исправлении
ошибок
в
своём
оборудовании
Нашумевшая
ошибка
с
fdiv
которая
сильно
подкосила
процессоры
Intel
Pentium
в
году
–
сделала
ещё
более
очевидным
тот
факт
что
высокотехнологичное
железо
подвержено
ошибкам
точно
также
как
и
софт
Данный
инцидент
породил
у
производителей
ещё
больше
интереса
к
архитектуре
процессоров
на
основе
микрокода
Поэтому
Intel
и
AMD
стали
строить
свои
процессоры
с
применением
технологии
микрокодов
Intel
–
начиная
с
Pentium
Pro
(P
)
выпущенного
в
году
AMD
–
начиная
с
K
выпущенного
в
году
Всё
тайное
становится
явным
Несмотря
на
то
что
производители
процессоров
стараются
держать
архитектуру
микрокодов
и
механизм
их
обновления
в
строжайшем
секрете
–
враг
не
дремлет
Крупицы
разрозненной
информации
(в
основном
из
патентов
вроде
AMD
RISC
[
])
и
вдумчивый
реверсинг
официальных
обновлений
для
BIOS
(как
это
было
с
K
[
])
–
постепенно
проливают
свет
на
тайну
микрокода
(см
например
на
рисунке
ниже
«механизм
обновления
микрокода
процессоров
AMD»)
А
благодаря
постоянной
эволюции
инструментария
для
реверсинга
(как
программного
так
и
аппаратного)
[
]
перспективным
методикам
фаззинга
[
]
и
появлению
таких
OpenSource-инструментов
как
Microparse
[
]
и
Sandsifter
[
]
–
киберзлоумышленник
может
узнать
о
микрокоде
всё
необходимое
для
того
чтобы
писать
на
нём
микрокодовую
малварь
Так
например
в
[
]
на
правах
«Hello
world!»
(первый
шаг
к
троянизации
микрокода)
разработан
«микрохук»
(микрокодовая
программа
перехватывающая
ассемблерную
инструкцию)
который
подсчитывает
сколько
раз
процессор
обращался
к
команде
div
Этот
микрохук
представляет
собой
инъекцию
в
обработчик
ассемблерной
инструкции
div
Там
же
[
]
представлен
более
продвинутый
микрохук
–
который
спокойно
себе
сидит
в
ассемблерной
инструкции
div
ebx
ничем
не
выдавая
своего
присутствия
и
активируется
только
когда
при
обращении
к
div
ebx
выполняются
конкретные
условия:
в
регистре
ebx
содержится
значение
B
а
в
регистре
eax
содержится
значение
A
Активируясь
этот
микрохук
увеличивает
значение
регистра
eip
(указатель
текущей
инструкции)
на
единицу
В
результате
выполнение
программы
(которая
имела
смелость
обратиться
к
инструкции
div
ebx)
продолжается
со
смещением:
ни
с
первого
байта
следующей
за
div
ebx
команды
а
с
её
второго
байта
Если
же
в
регистрах
eax
и
ebx
заданы
другие
значения
то
div
ebx
работает
в
обычном
режиме
Какая
в
этом
практическая
ценность?
Например
чтобы
незаметно
активировать
скрытую
цепочку
ассемблерных
инструкций
при
использовании
обфускационной
техники
с
«перекрываемыми
инструкциями»
[
]
Эти
два
примера
демонстрируют
как
законные
ассемблерные
инструкции
можно
использовать
для
сокрытия
в
них
произвольного
троянского
кода
При
этом
киберзлоумышленник
может
активировать
свою
вредоносную
полезную
нагрузку
–
в
том
числе
и
удалённо
Например
когда
необходимое
для
активации
условие
выполняется
на
веб-странице
контролируемой
злоумышленником
Это
возможно
благодаря
компиляторам
Just-in-Time
(JIT)
и
Ahead-of-Time
(AOT)
встроенным
в
современные
веб-браузеры
Эти
компиляторы
позволяют
испускать
предопределённый
поток
ассемблерных
инструкций
машинного
кода
–
даже
если
вы
пишете
программу
исключительно
на
высокоуровневом
JavaScript
(см
последний
листинг
–
чуть
выше)
Библиография
Теги:
Хабы:
+
Карма
Рейтинг
Карев
Владимир
Пишу
о
вычислительной
технике:
новой
и
антикварной
Публикации
Лучшие
за
сутки
Похожие
Истории
Работа
вакансий
Ближайшие
события
–
февраля
:
Онлайн
–
февраля
Онлайн
февраля
:
Онлайн
–
февраля
Онлайн
февраля
:
Онлайн
февраля
:
Онлайн
февраля
:
Онлайн
февраля
:
Онлайн
февраля
:
Онлайн
февраля
:
Онлайн
марта
–
апреля
:
Онлайн
–
марта
:
–
:
Москва
•
Онлайн
марта
:
–
:
Москва
•
Онлайн
Ваш
аккаунт
Разделы
Информация
Услуги
Настройка
языка
©
–
