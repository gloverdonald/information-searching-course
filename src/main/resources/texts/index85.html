Синхронизация
пользователей
Zimbra
Collaboration
OSE
на
основе
Active
Directory
/
Хабр
β
апр
в
:
Синхронизация
пользователей
Zimbra
Collaboration
OSE
на
основе
Active
Directory
мин
K
Предпосылки
Настраивая
сервер
zimbra
столкнулся
с
проблемой
синхронизации
пользователей
по
группе
в
Active
Directory
(AD)
Если
мы
создаем
нового
пользователя
в
AD
то
он
нормально
добавлялся
но
если
мы
делаем
доступ
к
почтовому
серверу
по
группе
то
первый
раз
все
пользователи
синхронизируются
А
вот
потом
изменения
в
группе
никак
не
влияют
на
изменения
пользователей
почтового
сервера
zimbra
Что
не
понравилось
в
этих
статьях
это
использование
скрипта
на
powershell
(зачем
если
есть
ldapsearch)
и
постоянный
вызов
утилиты
zmprov
и
когда
идет
синхронизация
большого
количества
пользователей
то
скрипт
выполняется
продолжительное
время
Исходные
данные
ОС
сервера:
CentOS
Язык
скрипта:
bash
Домен
Zimbra:
test
ru
Сервер
Zimbra:
zimbra
test
local
Домен
Active
Directory:
test
local
Группа
AD
для
доступа
к
почте:
mail
У
пользователя
может
быть
почта
отличающаяся
от
его
логина
такую
почту
вносим
в
AD
в
поле
mail
и
по
нему
создаем
алиас
в
zimbra
(например
вася
пупкин
входит
в
систему
под
логином
vasia
но
почту
должен
отправлять
и
получать
еще
как
пользователь
v
pupkin@test
ru)
Схема
работы
скрипта
Скрипт
синхронизации
У
скрипта
есть
два
режима
работы
—
это
запуск
без
параметров
тогда
отработают
только
блокировка
и
добавление
пользователей
И
запуск
с
параметром
«all»
тогда
будут
синхронизированны
все
пользователи
группы
mail
в
AD
Так
же
необходимо
обратить
внимание
на
использование
утилиты
декодирования
base
в
функции
синхронизации
ее
необходимо
использовать
для
полей
AD
в
которых
используются
русские
символы
Сам
скрипт:
#!/bin/bash
#
#
Определение
переменных
#
#
Общие
переменные
#Путь
к
рабочему
каталогу
path="/mnt/zimbra/user-sync"
#Временная
метка
timestamp=`date
+%F-%H-%M`
#путь
к
временным
файлам
tmp_dir=$path/tmp
#Путь
к
файлам
с
атрибутами
пользователей
zimbra
zim_us=$tmp_dir/zim-us
#путь
к
файлам
логов
log_dir=$path/log
#имя
лог-файла
log=$log_dir/grouplog_$timestamp
txt
#путь
ко
временному
файлу
со
списком
пользователей
usname=$tmp_dir/usname
#Путь
к
файлу
со
списком
команд
на
пакетное
выполнение
утилитой
zmprov
zmcmdfile=$tmp_dir/zmcmdfile
#путь
ко
временным
файлам
со
списком
атрибутов
пользователей
AD

userfil=$tmp_dir/userfil
#отправка
почты
mutt="/usr/bin/mutt"

#
#
переменные
сервера
zimbra
#имя
домена
Zimbra
domain="test
ru"
#путь
к
командлету
zmprov
zmprov="/opt/zimbra/bin/zmprov"
#
#
переменные
доступа
к
AD
по
LDAP
#LDAP
search
ldapsearch=/opt/zimbra/common/bin/ldapsearch
#
Подключение
к
серверу
(либо
сервер
либо
домен
(если
больше
одного
сервера))
ldap_server="ldap://test
local:
"
#Базовая
OU
поиска
basedn="DC=test
DC=local"
#Пользователь
и
пароль
для
доступа
к
AD
по
LDAP
binddn="CN=zimbra
CN=Users
DC=test
DC=local"
bindpw="qwe
"
#user
password

#Фильтр
поиска
-
кто
входит
в
группу
mail
filter="(memberof=cn=mail
cn=users
dc=test
dc=local)"
#какие
поля
данных
ищем
(логин
почту
и
поле
с
не
совпадающей
с
логином
почтой
для
алиаса
и
подписи)
fields="sAMAccountName
mail
description
displayName
givenName
cn
sn
department
title"
#конец
блока
переменных

#Начинаем
обработку

#Функции
обработки
#Запись
ошибки
в
лог
function
err_log()
{
if
[
$
-eq
];
then
		#echo
-n
"$(tput
hpa
$(tput
cols))$(tput
cub
)[OK]"
		#echo
		echo
$
"
[Ok]"
>>
$log
	else
		#echo
-n
"$(tput
hpa
$(tput
cols))$(tput
cub
)
[FAIL]"
		#echo
		echo
$
"
[Fail]"
>>
$log
	fi
}

#Проверка
существования
каталога
function
if_path
()
{
	#Если
каталог
не
существует
то
создаем
его
	if
[
!
-d
$
];
then
	#Создание
каталога
для
обработки
	echo
"Создание
каталога
$
"
>>
$log
	mkdir
-p
$

	err_log
$?
"Проверка
каталога
$
"
	
else
	echo
"Каталог
обработки
$
существует"
>>
$log	
fi
}

#Запись
в
файл
списка
пользователей
из
AD
function
search_users_AD()
{
	echo
"Запись
списка
пользователей
рассылки
из
AD
"
>>
$log
	$ldapsearch
-x
-o
ldif-wrap=no
-H
$ldap_server
-D
$binddn
-w
$bindpw
-b
$basedn
$filter
$fields
|

	grep
sAMAccountName
|

	egrep
-v
'^#|^$'
|

	awk
'{print
$
}'
|
	sort
>
$usname
ad
	echo
"Found
(Найдено)
"`cat
$usname
ad
|
wc
-l`"
Group
in
AD
(групп
в
AD)"
>>
$log
}

function
all_user_attr_zimbra()
{
	#Создаем
файл
со
списком
всех
пользователей
и
их
атрибутов
	$zmprov
-l
gaa
-v
$domain
>
$usname
gaa
	#Переходим
в
папку
где
будут
созданы
файлы
с
атрибутами
пользователей
	cd
$zim_us
	#разбиваем
файл
со
всеми
пользователями
на
файлы
с
атрибутами
только
одного
пользователя
	csplit
$usname
gaa
--prefix='user
'
--suffix-format='%
d
zim'
--elide-empty-files
-s
/"#
name"/
'{*}'

	#Переименовываем
файлы
по
пользователям
имя
берем
из
имени
пользователя
zimbra
в
файле
	for
i
in
$(
ls
$zim_us
)
	do
		nam=`grep
"#
name"
$zim_us/$i
|
awk
'{
print
$
}'
|
sed
's/@
*//g'`
		mv
-f
$zim_us/$i
$zim_us/$nam
	done
	cd
$path
}

#Запись
в
файл
списка
пользователей
из
zimbra

function
search_user_zimbra()
{
	echo
"Запись
списка
пользователей
из
zimbra
"
>>
$log
	ls
$zim_us
|
sort
>
$usname
tem
	#Удаляем
системные
аккаунты
из
проверки
файл
$path/system
acc
содержит
список
системных
пользователей
	diff
-u
-i
$usname
tem
$path/system
acc
|
sed
d
|
grep
^-
|
cut
-c
-
|
sort
>
$usname
zim
	#rm
-f
$usname
tem
	echo
"Found
(Найдено)
"`cat
$usname
zim
|
wc
-l`"
Group
in
Zimbra
(групп
в
Zimbra)"
>>
$log
	
}

#Разница
между
списками
пользователей
(для
добавления
или
блокировки
function
diff_user_list()
{
	diff
-u
-i
$usname
zim
$usname
ad
|
sed
d
|
sed
'/@
*/d'
>
$usname
diff
}

#добавление
пользователей
function
adduser()
{
#Проверяем
существование
пользователя
на
добавление	
adddif=`grep
^+
$usname
diff
|
sed
'
!d'`
	if
[
-n
$adddif
];
	then
		for
addus
in
$(
grep
^+
$usname
diff
|
cut
-c
-
)
		do
			#
проверяем
есть
ли
такой
пользователь
в
zimbra
(если
есть
-
разблокируем
нет
-
создаем)

ifclos=`grep
"zimbraAccountStatus:"
$zim_us/$addus
|
awk
'{print
$
}'
|
cut
-c
-
`
			if
[
$ifclos
=
"c"
];
			then
				echo
"ma
$addus@$domain
zimbraAccountStatus
active"
>>
$zmcmdfile
				echo
"Пользователь
$addus
разблокирован"
>>
$tmp_dir/send
txt
				if
[
$addus
!=
""
];
				then
					sync_one_user
$addus
				fi
			else
				#
-
пароль
пользователя
необходим
для
создания
пользователя
может
быть
любым
так
как
настроена
проверка
паролей
в
домене
AD
				echo
"ca
$addus@$domain
"
>>
$zmcmdfile
				echo
"Пользователь
$addus
создан"
>>
$tmp_dir/send
txt
				if
[
$addus
!=
""
];
				then
					sync_one_user
$addus
				fi
			fi
		done
		
	fi
}

#блокировка
пользователей
перед
отключением
function
block_user()
{
	deldif==`grep
^-
$usname
diff
|
sed
'
!d'`
	if
[
-n
$deldif
];
	then
		for
delus
in
$(
grep
^-
$usname
diff
|
cut
-c
-
)
		do
			#zimbraAccountStatus
closed
			if
[
$delus
!=
""
];
			then
				ifclos=`grep
"zimbraAccountStatus:"
$zim_us/$delus
|
awk
'{print
$
}'`
				if
[
"$ifclos"
!=
"closed"
];
				then
					echo
"user
closed
-
$delus"
					echo
"ma
$delus@$domain
zimbraAccountStatus
closed"
>>
$zmcmdfile
					echo
"Пользователь
$delus
заблокирован!
Удалите
его
с
сервера
самостоятельно!"
>>
$tmp_dir/send
txt
					echo
$delus
>>
$path/close

					cat
$path/close
|
sort
>
$path/close
diff
					echo
"$delus"

				fi
			fi
		done
	fi
}

#Функция
проверки
существования
атрибута
function
ifattr()
{
	if
char=`echo
$
|
cut
-c
-
`
	if
[[
-n
$
&&
$if
char
!=
""
]];
	#if
[
$
!=
""
];
	then

	
#echo
$

	
echo
-n
"
$
\"$
\""
>>
$zmcmdfile
	fi
}

#функция
синхронизации
пользователя
function
sync_one_user()
{
	echo
"Синхронизация
пользователя
$
"
>>
$log
	$ldapsearch
-x
-o
ldif-wrap=no
-H
$ldap_server
-D
$binddn
-w
$bindpw
-b
$basedn
"(sAMAccountName=$
)"
$fields
>
$userfil/$
ad
	
	#Создаемначало
строки
атрибутов
синхронизации
	echo
-n
"ma
"$
>>
$zmcmdfile
	
	#samacc=`grep
"sAMAccountName:"
$userfil/$
|
awk
'{print
$
}'`

		
	description=`grep
"description:"
$userfil/$
ad
|
awk
'{split
($
a
":
");
print
a[
]}'`
	#echo
$description
	ifattr
"description"
"$description"
		
	displayName=`grep
"displayName:"
$userfil/$
ad
|
awk
'{split
($
a
":
");
print
a[
]}'
|
base
-d`
	ifattr
"displayName"
"$displayName"
	
	givenName=`grep
"givenName:"
$userfil/$
ad
|
awk
'{split
($
a
":
");
print
a[
]}'
|
base
-d`
	ifattr
"givenName"
"$givenName"
	
	cn=`grep
"cn:"
$userfil/$
ad
|
awk
'{split
($
a
":
");
print
a[
]}'`
	ifattr
"cn"
"$cn"
	
	sn=`grep
"sn:"
$userfil/$
ad
|
awk
'{split
($
a
":
");
print
a[
]}'
|
base
-d`
	ifattr
"sn"
"$sn"
	
	department=`grep
"department:"
$userfil/$
ad
|
awk
'{split
($
a
":
");
print
a[
]}'
|
base
-d`
	ifattr
"company"
"$department"
	
	title=`grep
"title:"
$userfil/$
ad
|
awk
'{split
($
a
":
");
print
a[
]}'
|
base
-d`
	ifattr
"title"
"$title"
	
	#Вставляем
перевод
строки
в
файле
	echo
>>
$zmcmdfile
	#Добавляем
алиас
	mailnew=`grep
"mail:"
$userfil/$
ad
|
awk
'{print
$
}'`
	if
[
"$mailnew"
!=
""
];
	then

	#
[
-n
$mailnew
]

	#
echo
$

		#Проверяем
наличие
алиаса
у
пользователя
		#${
}
-
приводим
все
символы
к
нижнему
регистру
		useralias=`grep
"zimbraMailAlias:"
$zim_us/${
}
|
awk
'{print
$
}'`
	
if
[
$useralias
!=
$mailnew
];
		then
			echo
"aaa
\"$
@$domain\"
\"$mailnew\""
>>
$zmcmdfile
		fi
	fi
	#ifattr
"mail"
$mailnew
#	echo
$mailnew
	echo
"Синхронизация
пользователя
$
"
>>
$tmp_dir/send
txt

	
#	echo
"Пользователь
$
-
$atrruser"
	
	#echo
"Found
(Найдено)
"`cat
$usname
ad
|
wc
-l`"
Group
in
AD
(групп
в
AD)"
>>
$log
}


#Выполнение
скрипта
date
+%F-%H-%M
#
Проверка
существования
каталогов
#Корневой
каталог
обработки
if_path
$path
#Каталог
временных
файлов
if_path
$tmp_dir
#Каталог
лог-файла
if_path
$log_dir
#Каталог
со
списком
групп
if_path
$userfil
#каталог
со
файлами
пользователей
зимбра
if_path
$zim_us

#Очищаем
файл
со
списком
команд
на
пакетное
выполнение
утилитой
zmprov
:>
$zmcmdfile
#
Очищаем
тело
письма
администратору
:>
$tmp_dir/send
txt
#
Создаем
список
групп
рассылки
из
AD

search_users_AD

#
Создаем
список
существующих
в
zimbra
пользователей
all_user_attr_zimbra
#удаляем
лишних
(системных)
search_user_zimbra

#
Сравниваем
оба
списка
групп
рассылки
diff_user_list
#Блокируем
пользователей
block_user
#Создаем
или
разблокируем
новых
пользователей
adduser

#tckb
скрипту
передан
параметр
"all"
при
запуске
то
синхронизируем
всех
пользователей
находящихся
в
группе
mail
AD
if
[[
-n
$
&&
$
=
"all"
]];
then
	for
us
in
$(cat
$usname
ad
);
	do
	#	echo
$us
		sync_one_user
$us
	done
fi
#
запускаем
выполнение
всех
команд
утилитой
zmprov
из
файла
$zmprov
-f
$zmcmdfile
#
дописываем
в
лог
файл
с
командами

cat
$zmcmdfile
>>
$log
#Отправляем
письмо
с
изменениями
админу
(если
они
есть)
if
[
-s
$tmp_dir/send
txt
];
then
	$mutt
-s
"Синхронизация
списка
пользователей
$timestamp"
admins@test
ru
-a
$log
<
$tmp_dir/send
txt
fi

#Удаляем
временные
файлы
и
каталоги
rm
-R
-f
$tmp_dir

Заключение
В
целом
скрипт
получился
довольно
шустрый
утилита
zmprov
используется
всего
два
раза
остальные
утилиты
и
функции
отрабатывают
намного
быстрее
Ссылки
При
создании
данной
статьи
использовались
идеи
и
статьи:
Теги:
Хабы:
Если
эта
публикация
вас
вдохновила
и
вы
хотите
поддержать
автора
—
не
стесняйтесь
нажать
на
кнопку
Задонатить
+
Карма
Рейтинг
Михаил
Новохацкий
Пользователь
Публикации
Лучшие
за
сутки
Похожие
Истории
Работа
вакансий
вакансий
Ближайшие
события
–
февраля
:
Онлайн
–
февраля
Онлайн
февраля
:
Онлайн
–
февраля
Онлайн
февраля
:
Онлайн
февраля
:
Онлайн
февраля
:
Онлайн
февраля
:
Онлайн
февраля
:
Онлайн
февраля
:
Онлайн
марта
–
апреля
:
Онлайн
–
марта
:
–
:
Москва
•
Онлайн
марта
:
–
:
Москва
•
Онлайн
Ваш
аккаунт
Разделы
Информация
Услуги
Настройка
языка
©
–
