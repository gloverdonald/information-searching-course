Основы
Elasticsearch
/
Хабр
β
мар
в
:
Основы
Elasticsearch
мин
K
Elasticsearch
—
поисковый
движок
с
json
rest
api
использующий
Lucene
и
написанный
на
Java
Описание
всех
преимуществ
этого
движка
доступно
на
Далее
по
тексту
будем
называть
Elasticsearch
как
ES
Подобные
движки
используются
при
сложном
поиске
по
базе
документов
Например
поиск
с
учетом
морфологии
языка
или
поиск
по
geo
координатам
В
этой
статье
я
расскажу
про
основы
ES
на
примере
индексации
постов
блога
Покажу
как
фильтровать
сортировать
и
искать
документы
Чтобы
не
зависеть
от
операционной
системы
все
запросы
к
ES
я
буду
делать
с
помощью
CURL
Также
есть
плагин
для
google
chrome
под
названием
По
тексту
расставлены
ссылки
на
документацию
и
другие
источники
В
конце
размещены
ссылки
для
быстрого
доступа
к
документации
Определения
незнакомых
терминов
можно
прочитать
в
Установка
ES
Для
этого
нам
сначала
потребуется
Java
Разработчики
установить
версии
Java
новее
чем
Java
update
или
Java
update
Дистрибутив
ES
доступен
на
После
распаковки
архива
нужно
запустить
bin/elasticsearch
Также
доступны
Есть
После
установки
и
запуска
проверим
работоспособность:
#
для
удобства
запомним
адрес
в
переменную
#export
ES_URL=$(docker-machine
ip
dev):

export
ES_URL=localhost:


curl
-X
GET
$ES_URL
Нам
придет
приблизительно
такой
ответ:
{

"name"
:
"Heimdall"


"cluster_name"
:
"elasticsearch"


"version"
:
{

"number"
:
"
"


"build_hash"
:
"d
fc
d
bce
b
e
ab
b
fbf
cd
a
"


"build_timestamp"
:
"
-
-
T
:
:
Z"


"build_snapshot"
:
false


"lucene_version"
:
"
"

}


"tagline"
:
"You
Know
for
Search"
}
Индексация
Добавим
пост
в
ES:
#
Добавим
документ
c
id
типа
post
в
индекс
blog

#
?pretty
указывает
что
вывод
должен
быть
человеко-читаемым


curl
-XPUT
"$ES_URL/blog/post/
?pretty"
-d'
{

"title":
"Веселые
котята"


"content":
"<p>Смешная
история
про
котят<p>"


"tags":
[

"котята"


"смешная
история"

]


"published_at":
"
-
-
T
:
:
+
:
"
}'

ответ
сервера:
{

"_index"
:
"blog"


"_type"
:
"post"


"_id"
:
"
"


"_version"
:


"_shards"
:
{

"total"
:


"successful"
:


"failed"
:


}


"created"
:
false
}

ES
автоматически
создал
blog
и
post
Можно
провести
условную
аналогию:
индекс
—
это
база
данных
а
тип
—
таблица
в
этой
БД
Каждый
тип
имеет
свою
схему
—
также
как
и
реляционная
таблица
Mapping
генерируется
автоматически
при
индексации
документа:
#
Получим
mapping
всех
типов
индекса
blog
curl
-XGET
"$ES_URL/blog/_mapping?pretty"
В
ответе
сервера
я
добавил
в
комментариях
значения
полей
проиндексированного
документа:
{

"blog"
:
{

"mappings"
:
{

"post"
:
{

"properties"
:
{

/*
"content":
"<p>Смешная
история
про
котят<p>"
*/


"content"
:
{

"type"
:
"string"

}


/*
"published_at":
"
-
-
T
:
:
+
:
"
*/

"published_at"
:
{

"type"
:
"date"


"format"
:
"strict_date_optional_time||epoch_millis"

}


/*
"tags":
["котята"
"смешная
история"]
*/

"tags"
:
{

"type"
:
"string"

}


/*
"title":
"Веселые
котята"
*/

"title"
:
{

"type"
:
"string"

}

}

}

}

}
}
Стоит
отметить
что
ES
не
делает
различий
между
одиночным
значением
и
массивом
значений
Например
поле
title
содержит
просто
заголовок
а
поле
tags
—
массив
строк
хотя
они
представлены
в
mapping
одинаково
Позднее
мы
поговорим
о
маппинге
более
подобно
Запросы
Извлечение
документа
по
его
id:
#
извлечем
документ
с
id
типа
post
из
индекса
blog
curl
-XGET
"$ES_URL/blog/post/
?pretty"
{

"_index"
:
"blog"


"_type"
:
"post"


"_id"
:
"
"


"_version"
:


"found"
:
true


"_source"
:
{

"title"
:
"Веселые
котята"


"content"
:
"<p>Смешная
история
про
котят<p>"


"tags"
:
[
"котята"
"смешная
история"
]


"published_at"
:
"
-
-
T
:
:
+
:
"

}
}
В
ответе
появились
новые
ключи:
_version
и
_source
Вообще
все
ключи
начинающиеся
с
_
относятся
к
служебным
Ключ
_version
показывает
версию
документа
Он
нужен
для
работы
механизма
оптимистических
блокировок
Например
мы
хотим
изменить
документ
имеющий
версию
Мы
отправляем
измененный
документ
и
указываем
что
это
правка
документа
с
версией
Если
кто-то
другой
тоже
редактировал
документ
с
версией
и
отправил
изменения
раньше
нас
то
ES
не
примет
наши
изменения
т
к
он
хранит
документ
с
версией
Ключ
_source
содержит
тот
документ
который
мы
индексировали
ES
не
использует
это
значение
для
поисковых
операций
т
к
для
поиска
используются
индексы
Для
экономии
места
ES
хранит
сжатый
исходный
документ
Если
нам
нужен
только
id
а
не
весь
исходный
документ
то
можно
отключить
хранение
исходника
Если
нам
не
нужна
дополнительная
информация
можно
получить
только
содержимое
_source:
curl
-XGET
"$ES_URL/blog/post/
/_source?pretty"
{

"title"
:
"Веселые
котята"


"content"
:
"<p>Смешная
история
про
котят<p>"


"tags"
:
[
"котята"
"смешная
история"
]


"published_at"
:
"
-
-
T
:
:
+
:
"
}

Также
можно
выбрать
только
определенные
поля:
#
извлечем
только
поле
title
curl
-XGET
"$ES_URL/blog/post/
?_source=title&pretty"
{

"_index"
:
"blog"


"_type"
:
"post"


"_id"
:
"
"


"_version"
:


"found"
:
true


"_source"
:
{

"title"
:
"Веселые
котята"

}
}
Давайте
проиндексируем
еще
несколько
постов
и
выполним
более
сложные
запросы
curl
-XPUT
"$ES_URL/blog/post/
"
-d'
{

"title":
"Веселые
щенки"


"content":
"<p>Смешная
история
про
щенков<p>"


"tags":
[

"щенки"


"смешная
история"

]


"published_at":
"
-
-
T
:
:
+
:
"
}'
curl
-XPUT
"$ES_URL/blog/post/
"
-d'
{

"title":
"Как
у
меня
появился
котенок"


"content":
"<p>Душераздирающая
история
про
бедного
котенка
с
улицы<p>"


"tags":
[

"котята"

]


"published_at":
"
-
-
T
:
:
+
:
"
}'
Сортировка
#
найдем
последний
пост
по
дате
публикации
и
извлечем
поля
title
и
published_at
curl
-XGET
"$ES_URL/blog/post/_search?pretty"
-d'
{

"size":


"_source":
["title"
"published_at"]


"sort":
[{"published_at":
"desc"}]
}'
{

"took"
:


"timed_out"
:
false


"_shards"
:
{

"total"
:


"successful"
:


"failed"
:


}


"hits"
:
{

"total"
:


"max_score"
:
null


"hits"
:
[
{

"_index"
:
"blog"


"_type"
:
"post"


"_id"
:
"
"


"_score"
:
null


"_source"
:
{

"title"
:
"Веселые
котята"


"published_at"
:
"
-
-
T
:
:
+
:
"

}


"sort"
:
[
]

}
]

}
}
Мы
выбрали
последний
пост
size
ограничивает
кол-во
документов
в
выдаче
total
показывает
общее
число
документов
подходящих
под
запрос
sort
в
выдаче
содержит
массив
целых
чисел
по
которым
производится
сортировка
Т
е
дата
преобразовалась
в
целое
число
Подробнее
о
сортировке
можно
прочитать
в
Фильтры
и
запросы
ES
с
версии
не
различает
фильты
и
запросы
вместо
этого
Контекст
запроса
отличается
от
контекста
фильтра
тем
что
запрос
генерирует
_score
и
не
кэшируется
Что
такое
_score
я
покажу
позже
Фильтрация
по
дате
Используем
запрос
в
контексте
filter:
#
получим
посты
опубликованные
ого
сентября
или
позже
curl
-XGET
"$ES_URL/blog/post/_search?pretty"
-d'
{

"filter":
{

"range":
{

"published_at":
{
"gte":
"
-
-
"
}

}

}
}'
Фильтрация
по
тегам
Используем
для
поиска
id
документов
содержащих
заданное
слово:
#
найдем
все
документы
в
поле
tags
которых
есть
элемент
'котята'
curl
-XGET
"$ES_URL/blog/post/_search?pretty"
-d'
{

"_source":
[

"title"


"tags"

]


"filter":
{

"term":
{

"tags":
"котята"

}

}
}'
{

"took"
:


"timed_out"
:
false


"_shards"
:
{

"total"
:


"successful"
:


"failed"
:


}


"hits"
:
{

"total"
:


"max_score"
:


"hits"
:
[
{

"_index"
:
"blog"


"_type"
:
"post"


"_id"
:
"
"


"_score"
:


"_source"
:
{

"title"
:
"Веселые
котята"


"tags"
:
[
"котята"
"смешная
история"
]

}

}
{

"_index"
:
"blog"


"_type"
:
"post"


"_id"
:
"
"


"_score"
:


"_source"
:
{

"title"
:
"Как
у
меня
появился
котенок"


"tags"
:
[
"котята"
]

}

}
]

}
}
Полнотекстовый
поиск
Три
наших
документа
содержат
в
поле
content
следующее:
Используем
для
поиска
id
документов
содержащих
заданное
слово:
#
source:
false
означает
что
не
нужно
извлекать
_source
найденных
документов
curl
-XGET
"$ES_URL/blog/post/_search?pretty"
-d'
{

"_source":
false


"query":
{

"match":
{

"content":
"история"

}

}
}'
{

"took"
:


"timed_out"
:
false


"_shards"
:
{

"total"
:


"successful"
:


"failed"
:


}


"hits"
:
{

"total"
:


"max_score"
:


"hits"
:
[
{

"_index"
:
"blog"


"_type"
:
"post"


"_id"
:
"
"


"_score"
:


}
{

"_index"
:
"blog"


"_type"
:
"post"


"_id"
:
"
"


"_score"
:


}
{

"_index"
:
"blog"


"_type"
:
"post"


"_id"
:
"
"


"_score"
:


}
]

}
}
Однако
если
искать
"истории"
в
поле
контент
то
мы
ничего
не
найдем
т
к
в
индексе
содержатся
только
оригинальные
слова
а
не
их
основы
Для
того
чтобы
сделать
качественный
поиск
нужно
настроить
анализатор
Поле
_score
показывает
Если
запрос
выпоняется
в
filter
context
то
значение
_score
всегда
будет
равно
что
означает
полное
соответствие
фильтру
Анализаторы
нужны
чтобы
преобразовать
исходный
текст
в
набор
токенов
Анализаторы
состоят
из
одного
и
нескольких
необязательных
Tokenizer
может
предшествовать
нескольким
Tokenizer
разбивают
исходную
строку
на
токены
например
по
пробелам
и
символам
пунктуации
TokenFilter
может
изменять
токены
удалять
или
добавлять
новые
например
оставлять
только
основу
слова
убирать
предлоги
добавлять
синонимы
CharFilter
—
изменяет
исходную
строку
целиком
например
вырезает
html
теги
В
ES
есть
несколько
Например
анализатор
Воспользуемся
и
посмотрим
как
анализаторы
standard
и
russian
преобразуют
строку
"Веселые
истории
про
котят":
#
используем
анализатор
standard

#
обязательно
нужно
перекодировать
не
ASCII
символы
curl
-XGET
"$ES_URL/_analyze?pretty&analyzer=standard&text=%D
%
%D
%B
%D
%
%D
%B
%D
%BB%D
%
B%D
%B
%
%D
%B
%D
%
%D
%
%D
%BE%D
%
%D
%B
%D
%B
%
%D
%BF%D
%
%D
%BE%
%D
%BA%D
%BE%D
%
%D
%
F%D
%
"
{

"tokens"
:
[
{

"token"
:
"веселые"


"start_offset"
:


"end_offset"
:


"type"
:
"<ALPHANUM>"


"position"
:


}
{

"token"
:
"истории"


"start_offset"
:


"end_offset"
:


"type"
:
"<ALPHANUM>"


"position"
:


}
{

"token"
:
"про"


"start_offset"
:


"end_offset"
:


"type"
:
"<ALPHANUM>"


"position"
:


}
{

"token"
:
"котят"


"start_offset"
:


"end_offset"
:


"type"
:
"<ALPHANUM>"


"position"
:


}
]
}
#
используем
анализатор
russian
curl
-XGET
"$ES_URL/_analyze?pretty&analyzer=russian&text=%D
%
%D
%B
%D
%
%D
%B
%D
%BB%D
%
B%D
%B
%
%D
%B
%D
%
%D
%
%D
%BE%D
%
%D
%B
%D
%B
%
%D
%BF%D
%
%D
%BE%
%D
%BA%D
%BE%D
%
%D
%
F%D
%
"
{

"tokens"
:
[
{

"token"
:
"весел"


"start_offset"
:


"end_offset"
:


"type"
:
"<ALPHANUM>"


"position"
:


}
{

"token"
:
"истор"


"start_offset"
:


"end_offset"
:


"type"
:
"<ALPHANUM>"


"position"
:


}
{

"token"
:
"кот"


"start_offset"
:


"end_offset"
:


"type"
:
"<ALPHANUM>"


"position"
:


}
]
}
Стандартный
анализатор
разбил
строку
по
пробелам
и
перевел
все
в
нижний
регистр
анализатор
russian
—
убрал
не
значимые
слова
перевел
в
нижний
регистр
и
оставил
основу
слов
Посмотрим
какие
Tokenizer
TokenFilters
CharFilters
использует
анализатор
russian:
{

"filter":
{

"russian_stop":
{

"type":
"stop"


"stopwords":
"_russian_"

}


"russian_keywords":
{

"type":
"keyword_marker"


"keywords":
[]

}


"russian_stemmer":
{

"type":
"stemmer"


"language":
"russian"

}

}


"analyzer":
{

"russian":
{

"tokenizer":
"standard"


/*
TokenFilters
*/

"filter":
[

"lowercase"


"russian_stop"


"russian_keywords"


"russian_stemmer"

]

/*
CharFilters
отсутствуют
*/

}

}
}
Опишем
свой
анализатор
на
основе
russian
который
будет
вырезать
html
теги
Назовем
его
default
т
к
анализатор
с
таким
именем
будет
использоваться
по
умолчанию
{

"filter":
{

"ru_stop":
{

"type":
"stop"


"stopwords":
"_russian_"

}


"ru_stemmer":
{

"type":
"stemmer"


"language":
"russian"

}

}


"analyzer":
{

"default":
{

/*
добавляем
удаление
html
тегов
*/

"char_filter":
["html_strip"]


"tokenizer":
"standard"


"filter":
[

"lowercase"


"ru_stop"


"ru_stemmer"

]

}

}
}
Сначала
из
исходной
строки
удалятся
все
html
теги
потом
ее
разобьет
на
токены
tokenizer
standard
полученные
токены
перейдут
в
нижний
регистр
удалятся
незначимые
слова
и
от
оставшихся
токенов
останется
основа
слова
Создание
индекса
Выше
мы
описали
default
анализатор
Он
будет
применяться
ко
всем
строковым
полям
Наш
пост
содержит
массив
тегов
соответственно
теги
тоже
будут
обработаны
анализатором
Т
к
мы
ищем
посты
по
точному
соответствию
тегу
то
необходимо
отключить
анализ
для
поля
tags
Создадим
индекс
blog
с
анализатором
и
маппингом
в
котором
отключен
анализ
поля
tags:
curl
-XPOST
"$ES_URL/blog
"
-d'
{

"settings":
{

"analysis":
{

"filter":
{

"ru_stop":
{

"type":
"stop"


"stopwords":
"_russian_"

}


"ru_stemmer":
{

"type":
"stemmer"


"language":
"russian"

}

}


"analyzer":
{

"default":
{

"char_filter":
[

"html_strip"

]


"tokenizer":
"standard"


"filter":
[

"lowercase"


"ru_stop"


"ru_stemmer"

]

}

}

}

}


"mappings":
{

"post":
{

"properties":
{

"content":
{

"type":
"string"

}


"published_at":
{

"type":
"date"

}


"tags":
{

"type":
"string"


"index":
"not_analyzed"

}


"title":
{

"type":
"string"

}

}

}

}
}'
Добавим
те
же
поста
в
этот
индекс
(blog
)
Я
опущу
этот
процесс
т
к
он
аналогичен
добавлению
документов
в
индекс
blog
Полнотекстовый
поиск
с
поддержкой
выражений
Познакомимся
с
еще
одним
типом
запросов:
#
найдем
документы
в
которых
встречается
слово
'истории'
#
query
->
simple_query_string
->
query
содержит
поисковый
запрос
#
поле
title
имеет
приоритет

#
поле
tags
имеет
приоритет

#
поле
content
имеет
приоритет

#
приоритет
используется
при
ранжировании
результатов
curl
-XPOST
"$ES_URL/blog
/post/_search?pretty"
-d'
{

"query":
{

"simple_query_string":
{

"query":
"истории"


"fields":
[

"title^
"


"tags^
"


"content"

]

}

}
}'
Т
к
мы
используем
анализатор
с
русским
стеммингом
то
этот
запрос
вернет
все
документы
хотя
в
них
встречается
только
слово
'история'
Запрос
может
содержать
специальные
символы
например:
"\"fried
eggs\"
+(eggplant
|
potato)
-frittata"
Синтаксис
запроса:
+
signifies
AND
operation
|
signifies
OR
operation
-
negates
a
single
token
"
wraps
a
number
of
tokens
to
signify
a
phrase
for
searching
*
at
the
end
of
a
term
signifies
a
prefix
query
(
and
)
signify
precedence
~N
after
a
word
signifies
edit
distance
(fuzziness)
~N
after
a
phrase
signifies
slop
amount
#
найдем
документы
без
слова
'щенки'
curl
-XPOST
"$ES_URL/blog
/post/_search?pretty"
-d'
{

"query":
{

"simple_query_string":
{

"query":
"-щенки"


"fields":
[

"title^
"


"tags^
"


"content"

]

}

}
}'

#
получим
поста
про
котиков
Ссылки
PS
Если
интересны
подобные
статьи-уроки
есть
идеи
новых
статей
или
есть
предложения
о
сотрудничестве
то
буду
рад
сообщению
в
личку
или
на
почту
m
kuzmin+habr@darkleaf
ru
Теги:
Хабы:
+
Карма
Рейтинг
Михаил
Кузьмин
Пользователь
Публикации
Лучшие
за
сутки
Похожие
Истории
Ближайшие
события
–
февраля
:
Онлайн
–
февраля
Онлайн
февраля
:
Онлайн
–
февраля
Онлайн
февраля
:
Онлайн
февраля
:
Онлайн
февраля
:
Онлайн
февраля
:
Онлайн
февраля
:
Онлайн
февраля
:
Онлайн
марта
–
апреля
:
Онлайн
–
марта
:
–
:
Москва
•
Онлайн
марта
:
–
:
Москва
•
Онлайн
Ваш
аккаунт
Разделы
Информация
Услуги
Настройка
языка
©
–
